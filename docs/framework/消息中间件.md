# 消息中间件

## 目录

- [放大100倍压力，找出你系统的技术挑战](#放大100倍压力，找出你系统的技术挑战)
- [消息中间件](#消息中间件)
    - [消息中间件作用](#消息中间件作用)
    - [Kafka、RabbitMQ 以及 RocketMQ对比](#Kafka、RabbitMQ以及RocketMQ对比)
- [MQ的架构原理](#MQ的架构原理)
    - [RocketMQ架构原理](#RocketMQ架构原理)
        - [NameServer](#NameServer)
        - [Broker主从架构](#Broker主从架构)
        - [RocketMQ的核心数据模型](#RocketMQ的核心数据模型) 
        - [RocketMQ的集群部署](#RocketMQ的集群部署)
          - [小规模RocketMQ的集群部署](#小规模RocketMQ的集群部署)
          - [RocketMQ的集群可视化监控](#RocketMQ的集群可视化监控)
          - [RocketMQ生产参数调整](#RocketMQ生产参数调整)
          - [RocketMQ的集群压测](#RocketMQ的集群压测)
          - [RocketMQ生产集群的规划](#RocketMQ生产集群的规划)
        - [RocketMQ的发送消息的方式](#RocketMQ的发送消息的方式)
        - [RocketMQ的消费模式](#RocketMQ的消费模式)
    - [Kafka架构原理](#Kafka架构原理)
    - [RabbitMQ架构原理](#RabbitMQ架构原理)

# 消息中间件

## 放大100倍压力，找出你系统的技术挑战

思考一：系统的核心链路，有哪些步骤，各个步骤的性能如何，是否有改进空间？
    
        下单--预约--核销---退款
         其余的流程可以走MQ异步处理
思考二：系统中是否有类似后台线程定时补偿的逻辑
    
    订单长时间未支付，要关闭，
    预约单长时间无人确认接单，自动分单，
    秒杀活动/优惠券设置时间后要自动开始，到点后要自动结束

思考三：系统中有哪些和第三方系统的耦合？

        耦合微信支付，短信，推送等

思考四：核心链路中是否存在哪些关键步骤可能会失败的情况？万一失败了该怎么办？

     例如退款失败后怎么办

思考五：平时是否有其他系统需要获取你们的数据的情况？他们是如何获取数据的？

    是直接跑SQL从你们的数据库里查询？或者是调用你们的接口来获取数据？
    是否有这种情况？如果有，对你们有什么影响吗？
  
    可以基于mysql的binlog 日志将数据发送给MQ，别的部门从MQ中消费消息

思考六：你们的系统是否存在流量洪峰的情况，有时候突然之间访问量增大好几倍，是否对你们的系统产生无法承受的压力？
        
## 消息中间件

### 消息中间件作用

解耦
异步
消峰

### Kafka、RabbitMQ以及RocketMQ对比

（1）、Kafka的优势与劣势

   kafka 性能很高，基本发消息给kafka都是毫秒级的性能，可用性也很高，kafka支持集群部署的，其中部分宕机是可以继续运行的

   但是kafka比较为人诟病的一点，似乎是丢数据方能的问题，因为kafka收到消息后会写入一个磁盘缓冲区里，并没有落地到物理磁盘上，
    
   所以要是机器本身故障，可能会导致磁盘缓冲区数据丢失。
   
   而且kafka另外一个比较大的缺点，就是功能非常单一，主要支持发送消息给他，然后从里面消费消息，其他的就没有什么额外的高级功能了
   
   因此，综上所述，基本行业里的标准，是把kafka在用户行为日志的采集和传输上的，比如大数据团队要收集app上用于的一些行为日志，这种日志就是
   
   kafka收集传输的。

（2）、RabbitMQ的优势与劣势

   RabbitMQ的优势是可以保证数据不丢失，也可以保证高可用性，即集群部署的时候。部分机器宕机可以继续运行，然后支持部分高级功能
   比如说：死信队列，消息重试之类的

   但是他有个缺点最为人诟病的，就是RabbitMQ吞吐量比较低，一般就是每秒几万级别的，所以遇到特别高特别高的并发的情况下，支撑起来是有点困难的

   还有一个是它进行集群扩展的时候(就是加机器部署)，还是比较麻烦的


（2）、RocketMQ的优势与劣势

   RocketMQ吞吐量也同样很高，单机可以达到10wQPS以上，而且可以保证高可用，性能很高，而且支持配置，保证数据绝对不丢失，可以部署
   大规模集群，而且支持各种高级性能，比如说：延迟消息，事务消息，消息回溯，死信队列，消息积压等等
   
   
## MQ的架构原理

### RocketMQ架构原理

![img_1.png](images/RockerMQjiagou.png)

RocketMQ 这个技术一共包含了四个核心部分

    1.第一块就是他的NameServer，这个东西很重要，他要负责管理集群里所有Broker的信息，让使用MQ的系统能感知到集群里有哪些Broke。
    2.第二块就是Broke集群的本身信息，必须在多台机器上部署这么一个集群，而且还得用主从架构实现数据多副本和高可用。
    3.第三块就是消息生产者
    4.第四块就是消息的消费者

#### NameServer

NameServer的设计是采用Peer-to-Peer的模式来做的，可以集群化部署，但是里面任何一台机器都是独立运行的，跟其他机器没有任何通信。

要部署RocketMQ，就得先部署NameServer，NameServer支持集群化部署，做到高可用。任何一台机器宕机，NameServer可以继续对外提供服务。

每个Broker启动时都得向所有的NameServer进行注册，也就是说，每个NameServer都有一份集群中所有的Broker信息。

RocketMQ中的生产者和消费者自己主动区NameServer拉取Broker信息的

Broker和NameServer之间通过心跳机制（采用的是TCP长连接），Broker会每隔30s给所有的NameServer发送心跳，告诉NameServer自己还活着。

每次NameServer收到Broker心跳，就可以更新一下它的最近一次心跳时间。

然后NameServer 会每隔10s运行一个任务，区检查各个Broker的最近一次心跳，如果某个Broker超过120s都没发送心跳，那么就认为这个Broker已经挂掉。

生产者和消费者会重新获取NameServer最新的路由信息，并缓存在本地

#### Broker主从架构

为了保证RocketMQ的数据不丢失而且具备一定的高可用性，所以一般将Broker，部署成Master-Slave模式的，也就时一个Master Broker  对应一个Slave Broker

RocketMQ的Master-Slave模式采取的是（Pull模式）Slave Broker不停的发送请求到Master Broker 去拉取消息

**写入数据**的时候，肯定是选择**Master Broker** 去写入的

**读取数据**的时候，**有可能是Master Broker获取，有可能是Slave Broker 获取**，一切根据当时的情况来定。

如果Slave Broker 挂掉了，那么读写的压力都集中在Master Broker上。

如果Master Broker 挂掉了，在RocketMQ4.5版本之前，Slave Broker无法自定切换为Master Broker,会导致服务不可用。

RocketMQ 4.5之后的版本，RocketMQ支持一种新的机制，叫Dledger，可实现RocketMQ高可用自动切换的效果。

(备注:redis 的Master-Slaver 是基于哨兵模式，异曲同工）



#### RocketMQ的核心数据模型

MQ的核心数据模型 Topic

Topic其实就是一个数据集合的意思，不同的数据，你的放到不同的Topic里面。

每个Topic分布式存储在Master Broker上，Slave Broker或同步Master Broker 数据。

生产者跟NameServer建立一个TCP长连接，然后定时的从他那里拉取最新的路由信息，包含集群中有哪些Broker，哪些Topic，每个Topic存储在哪些Broker 上

然后生产者找到自己要投递的Topic分布在哪些Broker上，根据负载均衡算法，选择出一台Broker出来，然后跟这个Broker页建立一个TCP长连接，然后通过长连接向Broker发送消息即可。

这里要注意的是生产者一定是投递消息到Master Broker的，然后通过Master Broker会同步数据到他的Slave Broker上

实现一份数据多个副本，保证Master Broker故障之后，数据不丢失，而且可以把Slave Broker切换为Master Broker提供服务。


消费者页生产者类似，他们也会从NameServer建立长连接，然后拉取路由消息，找到自己消息的Topic在哪几台Broker上，就可以跟Broker建立长连接，从里面拉取消息了。

这里唯一要注意的就是消费者系统可能会从Master Broker拉取消息，也可以从Slave Broker拉取消息，都有可能，一切看具体情况。


#### RocketMQ的集群部署

##### 小规模RocketMQ的集群部署

##### RocketMQ的集群可视化监控

##### RocketMQ生产参数调整

##### RocketMQ的集群压测

##### RocketMQ生产集群的规划

### RocketMQ的发送消息的方式

    同步发送：生产者发送消息出去之后，登台MQ返回通知，程序在接着向下执行
    异步发送：生产者发送消息出去，无需登台MQ返回，直接向下执行，待MQ响应之后，callBack函数，
            如果发送成功，则调用onSuccess函数
            如果发送失败，则调用onException函数
    单向发送：生产者发送消息出去之后，代码向下执行，不关注MQ是否返回结果，无论消息发送成功或者发送失败都不管你的事。

### RocketMQ的消费模式

Push消费模式：就是Broker主动把消息发送给你的消费者
Pull消费模式：就是消费者主动发送请求到Broker去拉取消息
